{"version":3,"sources":["webpack:///webpack/bootstrap 6fb32e3e8883df818dcd","webpack:///./test/tests.ts","webpack:///./src/index.ts","webpack:///./~/dift/lib/index.js","webpack:///./~/bit-vector/lib/index.js"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uBAAe;AACf;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;;;;ACtCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA8C;AAC9C,4CAA2C,YAAY;AACvD,4CAA2C,YAAY;AACvD,+CAA8C,gBAAgB;AAC9D,+CAA8C;AAC9C,+CAA8C;AAC9C,gDAA+C,OAAO;AACtD,+CAA8C,YAAY,OAAO;AACjE,iCAAgC,eAAe;AAC/C,iCAAgC;AAChC;AACA;AACA;AACA;AACA,iCAAgC,4BAA4B;AAC5D,iCAAgC,mCAAmC;AACnE,iCAAgC,yDAAyD;AACzF,iCAAgC;AAChC,oBAAmB,SAAS;AAC5B,oBAAmB,SAAS;AAC5B,oBAAmB,SAAS;AAC5B,qBAAoB;AACpB,oBAAmB,SAAS;AAC5B,oBAAmB,SAAS;AAC5B,oBAAmB,SAAS;AAC5B;AACA,iCAAgC;AAChC,oBAAmB,SAAS;AAC5B,oBAAmB,SAAS;AAC5B,qBAAoB;AACpB,oBAAmB,SAAS;AAC5B,oBAAmB,SAAS;AAC5B,oBAAmB,SAAS;AAC5B;AACA,iCAAgC;AAChC,oBAAmB,SAAS;AAC5B,oBAAmB,SAAS;AAC5B,oBAAmB,SAAS;AAC5B,qBAAoB;AACpB,oBAAmB,SAAS;AAC5B;AACA,iCAAgC;AAChC,oBAAmB,SAAS;AAC5B,oBAAmB,SAAS;AAC5B,oBAAmB,SAAS;AAC5B,qBAAoB;AACpB,iCAAgC,eAAe;AAC/C,oBAAmB,SAAS;AAC5B,oBAAmB,SAAS;AAC5B,oBAAmB,SAAS;AAC5B;AACA,kCAAiC,OAAO,YAAY,OAAO;AAC3D,kCAAiC,OAAO,QAAQ,YAAY;AAC5D,iCAAgC,gBAAgB,OAAO;AACvD;AACA;;;;;;;;;;AC5FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,EAAC,4CAA4C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAe,kBAAkB;AACjC;AACA;AACA,uBAAsB,gEAAgE;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAqD,eAAe;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA4D,kBAAkB;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAmB,qBAAqB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAuB,yBAAyB;AAChD;AACA;AACA;AACA;;;;;;;;;;AC5RA;;AAEA;AACA;AACA,EAAC;AACD;;AAEA;;AAEA;AACA;AACA;;AAEA,gBAAe;AACf;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,SAAQ,sBAAsB;AAC9B;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAwB,8BAA8B;AACtD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,sBAAqB,SAAS;AAC9B;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,yB;;;;;;;;;AC7JA;;AAEA;AACA;AACA,EAAC;AACD;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,yB","file":"tests.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 6fb32e3e8883df818dcd\n **/","\"use strict\";\nvar index_1 = require('../src/index');\nvar Div = 'div';\nvar A = 'a';\nvar Br = 'br';\nvar parent = document.getElementById('tests');\nfunction domToHtmlString(dom) {\n    if (!dom)\n        return undefined;\n    var div = document.createElement('div');\n    div.appendChild(dom);\n    return div.innerHTML;\n}\nfunction clearNode(node) {\n    while (node.firstChild) {\n        node.removeChild(node.firstChild);\n    }\n}\nfunction checkUpdate(parent, vDomA, vDomB) {\n    clearNode(parent);\n    var dom = index_1.vDomToDom(vDomA);\n    var vDomB2 = vDomB instanceof Array ? vDomB.slice() : vDomB;\n    parent.appendChild(dom);\n    index_1.updateDom(vDomA, vDomB, dom, parent);\n    return domToHtmlString(parent.firstChild) === index_1.vDomToHtmlString(vDomB2);\n}\nfunction Child(_a) {\n    var a = _a.a;\n    return [Div, {}, [a]];\n}\nwindow['results'] = [\n    index_1.vDomToDom(null) === undefined,\n    index_1.vDomToDom(undefined) === undefined,\n    domToHtmlString(index_1.vDomToDom('a')) === '<span>a</span>',\n    domToHtmlString(index_1.vDomToDom(1)) === '<span>1</span>',\n    domToHtmlString(index_1.vDomToDom(0)) === '<span>0</span>',\n    domToHtmlString(index_1.vDomToDom([Br])) === '<br>',\n    domToHtmlString(index_1.vDomToDom([Div, {}, []])) === '<div></div>',\n    domToHtmlString(index_1.vDomToDom([A, { name: 'x' }])) === '<a name=\"x\"></a>',\n    domToHtmlString(index_1.vDomToDom([A, { href: '#' }, ['abc']])) === '<a href=\"#\"><span>abc</span></a>',\n    domToHtmlString(index_1.vDomToDom([Div, {}, ['a', [Div, {}, ['b']], 'c']])) === '<div><span>a</span><div><span>b</span></div><span>c</span></div>',\n    domToHtmlString(index_1.vDomToDom([Div, {}, ['a', 'b', 'c']])) === '<div><span>a</span><span>b</span><span>c</span></div>',\n    domToHtmlString(index_1.vDomToDom([Div, {}, ['a', false, 'b', undefined, null, 'c', null]])) === '<div><span>a</span><span>b</span><span>c</span></div>',\n    domToHtmlString(index_1.vDomToDom([Child, { a: 1 }])) === '<div><span>1</span></div>',\n    domToHtmlString(index_1.vDomToDom([Div, {}, [[Child, { a: 1 }]]])) === '<div><div><span>1</span></div></div>',\n    checkUpdate(parent, [Div, {}, []], [Div, {}, ['a']]),\n    checkUpdate(parent, [Div, {}, []], [Br]),\n    checkUpdate(parent, [Div], 'a'),\n    checkUpdate(parent, 'a', 'b'),\n    checkUpdate(parent, 'a', [Div]),\n    checkUpdate(parent, 1, 0),\n    checkUpdate(parent, [Div, {}, ['a', 'b', 'c']], [Div, {}, ['123']]),\n    checkUpdate(parent, [Div, {}, ['a', false, 'b', 'c']], [Div, {}, ['c', false, 'a', 'b']]),\n    checkUpdate(parent, [Div, {}, [undefined, undefined, 'a', false, 'b', 'c']], [Div, {}, ['c', 'd', 123, false, 'a', 'b', undefined]]),\n    checkUpdate(parent, [Div, {}, [\n            [Div, { key: 1 }],\n            [Div, { key: 2 }],\n            [Div, { key: 3 }],\n        ]], [Div, {}, [\n            [Div, { key: 3 }],\n            [Div, { key: 2 }],\n            [Div, { key: 1 }],\n        ]]),\n    checkUpdate(parent, [Div, {}, [\n            [Div, { key: 1 }],\n            [Div, { key: 3 }],\n        ]], [Div, {}, [\n            [Div, { key: 3 }],\n            [Div, { key: 2 }],\n            [Div, { key: 1 }],\n        ]]),\n    checkUpdate(parent, [Div, {}, [\n            [Div, { key: 1 }],\n            [Div, { key: 2 }],\n            [Div, { key: 3 }],\n        ]], [Div, {}, [\n            [Div, { key: 2 }]\n        ]]),\n    checkUpdate(parent, [Div, {}, [\n            [Div, { key: 1 }],\n            [Div, { key: 2 }],\n            [Div, { key: 3 }],\n        ]], [Div, {}, []]),\n    checkUpdate(parent, [Div, {}, []], [Div, {}, [\n            [Div, { key: 3 }],\n            [Div, { key: 2 }],\n            [Div, { key: 1 }],\n        ]]),\n    checkUpdate(parent, [Child, { a: 1 }], [Child, { a: 2 }]),\n    checkUpdate(parent, [Child, { a: 1 }], [A, { href: '#' }, ['x']]),\n    checkUpdate(parent, [Div, {}, []], [Child, { a: 1 }])\n];\nconsole.log(window['results']);\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./test/tests.ts\n ** module id = 0\n ** module chunks = 0\n **/","\"use strict\";\nvar dift_1 = require('dift');\nvar STRING = 'string';\nvar NUMBER = 'number';\nvar FUNCTION = 'function';\nvar KEY = 'key';\nvar VALUE = 'value';\nvar CHECKED = 'checked';\nvar SELECTED = 'selected';\nvar DISABLED = 'disabled';\nvar FOCUS = 'focus';\nvar ON = 'on';\nvar EMPTYSTRING = '';\nvar VOID_ELEMENTS = { area: 1, base: 1, br: 1, col: 1, command: 1, embed: 1, hr: 1, img: 1, input: 1, keygen: 1, link: 1, meta: 1, param: 1, source: 1, track: 1, wbr: 1 };\n(function (VDomType) {\n    VDomType[VDomType[\"VATOM\"] = 0] = \"VATOM\";\n    VDomType[VDomType[\"VNODE\"] = 1] = \"VNODE\";\n    VDomType[VDomType[\"VCHILD\"] = 2] = \"VCHILD\";\n    VDomType[VDomType[\"VNULL\"] = 3] = \"VNULL\";\n})(exports.VDomType || (exports.VDomType = {}));\nvar VDomType = exports.VDomType;\nfunction getType(vDom) {\n    if (vDom instanceof Array) {\n        return typeof vDom[0] === FUNCTION ? VDomType.VCHILD : VDomType.VNODE;\n    }\n    else if (typeof vDom === STRING || typeof vDom === NUMBER) {\n        return VDomType.VATOM;\n    }\n    else {\n        return VDomType.VNULL;\n    }\n}\nfunction keyOf(vDom, i) {\n    return (vDom instanceof Array && vDom[1] && vDom[1].key) || i;\n}\nfunction groupChildren(vDoms, DChildren) {\n    var res = [];\n    var v;\n    var i;\n    for (i = 0; i < vDoms.length; i++) {\n        v = vDoms[i];\n        if (!(v === false || v === undefined || v === null)) {\n            res.push({ key: keyOf(v, i), vDom: v, element: DChildren && DChildren[i] });\n        }\n    }\n    return res;\n}\nfunction getKey(v) {\n    return v.key;\n}\nfunction updateChildren(currentChildren, nextChildren, D) {\n    dift_1[\"default\"](groupChildren(currentChildren, D.childNodes), groupChildren(nextChildren), function effect(type, current, next, pos) {\n        switch (type) {\n            case dift_1.CREATE:\n                D.insertBefore(vDomToDom(next.vDom), D.childNodes[pos] || null);\n                break;\n            case dift_1.UPDATE:\n                updateDom(current.vDom, next.vDom, current.element, D);\n                break;\n            case dift_1.MOVE:\n                D.insertBefore(updateDom(current.vDom, next.vDom, current.element, D), current.element);\n                break;\n            case dift_1.REMOVE:\n                D.removeChild(current.element);\n                break;\n        }\n    }, getKey);\n    return D;\n}\nfunction updateDom(current, next, D, DParent) {\n    if (D === undefined) {\n        throw new Error('No dom node to update');\n    }\n    if (current === next) {\n        return;\n    }\n    var currentExists = current !== undefined;\n    var nextExists = next !== undefined;\n    if (!currentExists && nextExists) {\n        DParent.appendChild(vDomToDom(next));\n    }\n    else if (currentExists && !nextExists) {\n        DParent.removeChild(D);\n    }\n    else if (currentExists && nextExists) {\n        var currentType = getType(current);\n        var nextType = getType(next);\n        if (shouldExploreFurther(current, next, currentType, nextType)) {\n            switch (nextType) {\n                case VDomType.VNODE:\n                    updateAttributes(current[1] || {}, next[1] || {}, D);\n                    updateChildren(current[2] || [], next[2] || [], D);\n                    break;\n                case VDomType.VCHILD:\n                    if (next[0].shouldUpdate ?\n                        next[0].shouldUpdate(current[1], next[1]) :\n                        next[1] && current[1] && next[1] !== current[1]) {\n                        next[2] = next[0](next[1]);\n                        updateAttributes(current[2][1] || {}, next[2][1] || {}, D);\n                        updateChildren(current[2][2] || [], next[2][2] || [], D);\n                    }\n                    else {\n                        next[2] = current[2];\n                    }\n                    break;\n            }\n        }\n        else if (current !== next) {\n            DParent.replaceChild(vDomToDom(next), D);\n        }\n    }\n    return D;\n}\nexports.updateDom = updateDom;\nfunction updateAttributes(currentAttrs, nextAttrs, D) {\n    var a;\n    var currentVal;\n    var nextVal;\n    var evt;\n    var currentEvts = currentAttrs[ON];\n    var nextEvts = nextAttrs[ON];\n    for (a in currentAttrs) {\n        currentVal = currentAttrs[a];\n        nextVal = nextAttrs[a];\n        if (nextVal === undefined || nextVal === null || nextVal === false) {\n            switch (a) {\n                case ON:\n                case KEY:\n                    break;\n                case CHECKED:\n                case DISABLED:\n                case SELECTED:\n                    D[a] = false;\n                    break;\n                case VALUE:\n                    D['value'] = EMPTYSTRING;\n                    break;\n                case FOCUS:\n                    D['blur']();\n                    break;\n                default:\n                    D['removeAttribute'](a);\n                    break;\n            }\n        }\n    }\n    for (a in nextAttrs) {\n        currentVal = currentAttrs[a];\n        nextVal = nextAttrs[a];\n        if (!(nextVal === undefined || nextVal === null || nextVal === false) &&\n            nextVal !== currentVal &&\n            typeof nextVal !== FUNCTION) {\n            switch (a) {\n                case ON:\n                case KEY:\n                    break;\n                case CHECKED:\n                case DISABLED:\n                case SELECTED:\n                case VALUE:\n                    D[a] = nextVal;\n                    break;\n                case FOCUS:\n                    D['focus']();\n                    break;\n                default:\n                    D['setAttribute'](a, nextVal);\n                    break;\n            }\n        }\n    }\n    // update event listeners\n    if (currentEvts && !nextEvts) {\n        for (evt in currentEvts) {\n            D.removeEventListener(evt, currentEvts[evt]);\n        }\n    }\n    else if (!currentEvts && nextEvts) {\n        for (evt in nextEvts) {\n            D.addEventListener(evt, nextEvts[evt]);\n        }\n    }\n    else if (currentEvts && nextEvts) {\n        for (evt in currentEvts) {\n            if (!nextEvts[evt]) {\n                D.removeEventListener(evt, currentEvts[evt]);\n            }\n        }\n        for (evt in nextEvts) {\n            if (currentEvts[evt] !== nextEvts[evt]) {\n                if (currentEvts[evt]) {\n                    D.removeEventListener(evt, currentEvts[evt]);\n                }\n                D.addEventListener(evt, nextEvts[evt]);\n            }\n        }\n    }\n    return D;\n}\nfunction shouldExploreFurther(current, next, currentType, nextType) {\n    return currentType === nextType &&\n        (currentType === VDomType.VNODE || currentType === VDomType.VCHILD) &&\n        current[0] === next[0];\n}\nfunction vDomToHtmlString(vDom) {\n    switch (getType(vDom)) {\n        case VDomType.VCHILD:\n            vDom[2] = vDom[0](vDom[1]);\n            return vNodeToHtmlString(vDom[2]);\n        case VDomType.VNODE:\n            return vNodeToHtmlString(vDom);\n        case VDomType.VATOM:\n            return String(vDom);\n        default:\n            return '';\n    }\n}\nexports.vDomToHtmlString = vDomToHtmlString;\nfunction vNodeToHtmlString(vDom) {\n    var tag = vDom[0];\n    var attrs = vDom[1];\n    var children = vDom[2];\n    var attrPairs = [];\n    var val;\n    var a;\n    var c;\n    var res;\n    for (a in attrs) {\n        val = attrs[a];\n        if (!(val === undefined || val === null || val === false) && a !== KEY && a !== ON) {\n            attrPairs.push(a + '=\"' + val + '\"');\n        }\n    }\n    res = '<' + [tag].concat(attrPairs).join(' ') + '>';\n    if (!VOID_ELEMENTS[tag]) {\n        for (c = 0; c < children.length; c++) {\n            if (!(c === undefined || c === null || c === false)) {\n                res += vDomToHtmlString(children[c]);\n            }\n        }\n        res += '</' + tag + '>';\n    }\n    return res;\n}\nexports.vNodeToHtmlString = vNodeToHtmlString;\nfunction vDomToDom(vDom) {\n    switch (getType(vDom)) {\n        case VDomType.VATOM:\n            return document.createTextNode(String(vDom));\n        case VDomType.VNODE:\n        case VDomType.VCHILD:\n            var el = document.createElement('div');\n            el.innerHTML = vDomToHtmlString(vDom);\n            var dom = el.firstChild;\n            bindEvents(vDom, dom);\n            return dom;\n        default:\n            throw new Error('Null vdom');\n    }\n}\nexports.vDomToDom = vDomToDom;\nfunction bindEvents(vDom, D) {\n    var vType = getType(vDom);\n    var vNode;\n    var evts;\n    var evt;\n    var child;\n    var children;\n    if (vType === VDomType.VATOM || vType === VDomType.VNULL) {\n        return;\n    }\n    vNode = vType === VDomType.VCHILD ? vDom[2] : vDom;\n    evts = vNode[1][ON];\n    children = vNode[2];\n    if (evts) {\n        for (evt in evts) {\n            D.addEventListener(evt, evts[evt]);\n        }\n    }\n    if (children) {\n        for (child = 0; child < children.length; child++) {\n            bindEvents(children[child], D.childNodes[child]);\n        }\n    }\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/index.ts\n ** module id = 1\n ** module chunks = 0\n **/","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.REMOVE = exports.MOVE = exports.UPDATE = exports.CREATE = undefined;\n\nvar _bitVector = require('bit-vector');\n\n/**\n * Actions\n */\n\nvar CREATE = 0; /**\n                 * Imports\n                 */\n\nvar UPDATE = 1;\nvar MOVE = 2;\nvar REMOVE = 3;\n\n/**\n * dift\n */\n\nfunction dift(prev, next, effect, key) {\n  var pStartIdx = 0;\n  var nStartIdx = 0;\n  var pEndIdx = prev.length - 1;\n  var nEndIdx = next.length - 1;\n  var pStartItem = prev[pStartIdx];\n  var nStartItem = next[nStartIdx];\n\n  // List head is the same\n  while (pStartIdx <= pEndIdx && nStartIdx <= nEndIdx && equal(pStartItem, nStartItem)) {\n    effect(UPDATE, pStartItem, nStartItem, nStartIdx);\n    pStartItem = prev[++pStartIdx];\n    nStartItem = next[++nStartIdx];\n  }\n\n  // The above case is orders of magnitude more common than the others, so fast-path it\n  if (nStartIdx > nEndIdx && pStartIdx > pEndIdx) {\n    return;\n  }\n\n  var pEndItem = prev[pEndIdx];\n  var nEndItem = next[nEndIdx];\n  var movedFromFront = 0;\n\n  // Reversed\n  while (pStartIdx <= pEndIdx && nStartIdx <= nEndIdx && equal(pStartItem, nEndItem)) {\n    effect(MOVE, pStartItem, nEndItem, pEndIdx - movedFromFront + 1);\n    pStartItem = prev[++pStartIdx];\n    nEndItem = next[--nEndIdx];\n    ++movedFromFront;\n  }\n\n  // Reversed the other way (in case of e.g. reverse and append)\n  while (pEndIdx >= pStartIdx && nStartIdx <= nEndIdx && equal(nStartItem, pEndItem)) {\n    effect(MOVE, pEndItem, nStartItem, nStartIdx);\n    pEndItem = prev[--pEndIdx];\n    nStartItem = next[++nStartIdx];\n    --movedFromFront;\n  }\n\n  // List tail is the same\n  while (pEndIdx >= pStartIdx && nEndIdx >= nStartIdx && equal(pEndItem, nEndItem)) {\n    effect(UPDATE, pEndItem, nEndItem, nEndIdx);\n    pEndItem = prev[--pEndIdx];\n    nEndItem = next[--nEndIdx];\n  }\n\n  if (pStartIdx > pEndIdx) {\n    while (nStartIdx <= nEndIdx) {\n      effect(CREATE, null, nStartItem, nStartIdx);\n      nStartItem = next[++nStartIdx];\n    }\n\n    return;\n  }\n\n  if (nStartIdx > nEndIdx) {\n    while (pStartIdx <= pEndIdx) {\n      effect(REMOVE, pStartItem);\n      pStartItem = prev[++pStartIdx];\n    }\n\n    return;\n  }\n\n  var created = 0;\n  var pivotDest = null;\n  var pivotIdx = pStartIdx - movedFromFront;\n  var keepBase = pStartIdx;\n  var keep = (0, _bitVector.createBv)(pEndIdx - pStartIdx);\n\n  var prevMap = keyMap(prev, pStartIdx, pEndIdx + 1, key);\n\n  for (; nStartIdx <= nEndIdx; nStartItem = next[++nStartIdx]) {\n    var oldIdx = prevMap[key(nStartItem)];\n\n    if (isUndefined(oldIdx)) {\n      effect(CREATE, null, nStartItem, pivotIdx++);\n      ++created;\n    } else if (pStartIdx !== oldIdx) {\n      (0, _bitVector.setBit)(keep, oldIdx - keepBase);\n      effect(MOVE, prev[oldIdx], nStartItem, pivotIdx++);\n    } else {\n      pivotDest = nStartIdx;\n    }\n  }\n\n  if (pivotDest !== null) {\n    (0, _bitVector.setBit)(keep, 0);\n    effect(MOVE, prev[pStartIdx], next[pivotDest], pivotDest);\n  }\n\n  // If there are no creations, then you have to\n  // remove exactly max(prevLen - nextLen, 0) elements in this\n  // diff. You have to remove one more for each element\n  // that was created. This means once we have\n  // removed that many, we can stop.\n  var necessaryRemovals = prev.length - next.length + created;\n  for (var removals = 0; removals < necessaryRemovals; pStartItem = prev[++pStartIdx]) {\n    if (!(0, _bitVector.getBit)(keep, pStartIdx - keepBase)) {\n      effect(REMOVE, pStartItem);\n      ++removals;\n    }\n  }\n\n  function equal(a, b) {\n    return key(a) === key(b);\n  }\n}\n\nfunction isUndefined(val) {\n  return typeof val === 'undefined';\n}\n\nfunction keyMap(items, start, end, key) {\n  var map = {};\n\n  for (var i = start; i < end; ++i) {\n    map[key(items[i])] = i;\n  }\n\n  return map;\n}\n\n/**\n * Exports\n */\n\nexports.default = dift;\nexports.CREATE = CREATE;\nexports.UPDATE = UPDATE;\nexports.MOVE = MOVE;\nexports.REMOVE = REMOVE;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/dift/lib/index.js\n ** module id = 2\n ** module chunks = 0\n **/","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * Use typed arrays if we can\n */\n\nvar FastArray = typeof Uint32Array === 'undefined' ? Array : Uint32Array;\n\n/**\n * Bit vector\n */\n\nfunction createBv(sizeInBits) {\n  return new FastArray(Math.ceil(sizeInBits / 32));\n}\n\nfunction setBit(v, idx) {\n  var r = idx % 32;\n  var pos = (idx - r) / 32;\n\n  v[pos] |= 1 << r;\n}\n\nfunction clearBit(v, idx) {\n  var r = idx % 32;\n  var pos = (idx - r) / 32;\n\n  v[pos] &= ~(1 << r);\n}\n\nfunction getBit(v, idx) {\n  var r = idx % 32;\n  var pos = (idx - r) / 32;\n\n  return !!(v[pos] & 1 << r);\n}\n\n/**\n * Exports\n */\n\nexports.createBv = createBv;\nexports.setBit = setBit;\nexports.clearBit = clearBit;\nexports.getBit = getBit;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/bit-vector/lib/index.js\n ** module id = 3\n ** module chunks = 0\n **/"],"sourceRoot":""}